<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì£¼ì°¨ì¥ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ ì‹œë®¬ë ˆì´ì…˜</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter í°íŠ¸ ì‚¬ìš© */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 95vw;
        }
        canvas {
            border: 2px solid #333;
            background-color: #4A4A4A; /* ì£¼ì°¨ì¥ ë°”ë‹¥ ìƒ‰ìƒ */
            border-radius: 8px;
            touch-action: none; /* ìº”ë²„ìŠ¤ ë‚´ í„°ì¹˜ ì´ë²¤íŠ¸ ë°©ì§€ */
        }
        #result-display {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            text-align: center;
            min-height: 2em;
        }
    </style>
</head>
<body>

<div class="container">
    <h1 class="text-3xl font-bold text-gray-800 text-center">ğŸš— ì£¼ì°¨ì¥ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ ì‹œë®¬ë ˆì´ì…˜ (ë™ì  ê³µê°„)</h1>
    
    <div id="result-display" class="bg-blue-100 p-3 rounded-lg shadow-inner">
        ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
    </div>

    <canvas id="parkingCanvas" width="750" height="450"></canvas>

    <div class="flex justify-center gap-4">
        <button id="startButton" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-6 rounded-full transition duration-300 shadow-md">
            ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ / ì´ˆê¸°í™”
        </button>
    </div>
</div>

<script>
    // Constants
    const CANVAS_ID = 'parkingCanvas';
    const RESULT_DISPLAY_ID = 'result-display';
    const START_BUTTON_ID = 'startButton';
    
    // Grid Setup
    const COLS = 25;
    const ROWS = 15;
    const TILE_SIZE = 30; // 30x30 pixels
    
    // Map Codes
    const PATH = 0;       // í†µë¡œ (ì´ë™ ê°€ëŠ¥)
    const WALL = 1;       // ë²½/ì ìœ ëœ ê³µê°„ (ì´ë™ ë¶ˆê°€ëŠ¥)
    const ENTRANCE = 2;   // ì…êµ¬/ìë™ì°¨ ì‹œì‘ ìœ„ì¹˜
    
    // ë¹ˆ ê³µê°„ ì½”ë“œ ì •ì˜ (3ë¶€í„° 9ê¹Œì§€ í• ë‹¹)
    const EMPTY_A = 3;
    const EMPTY_B = 4;
    const EMPTY_C = 5;
    const SCAN = 6;       // BFS ìŠ¤ìº” ì¤‘ì¸ ê²½ë¡œ
    const SHORTEST_PATH = 7; // ìµœì¢… ì„ íƒëœ ìµœë‹¨ ê²½ë¡œ
    const EMPTY_D = 8;    // ë¹ˆ ê³µê°„ D (ìƒˆë¡œ ì¶”ê°€ë¨)
    const EMPTY_E = 9;    // ë¹ˆ ê³µê°„ E (ìƒˆë¡œ ì¶”ê°€ë¨)

    // ëª¨ë“  ë¹ˆ ê³µê°„ ì½”ë“œë¥¼ ì €ì¥í•˜ì—¬ ë™ì  í™•ì¸ì— ì‚¬ìš©
    const ALL_EMPTY_CODES = [EMPTY_A, EMPTY_B, EMPTY_C, EMPTY_D, EMPTY_E];

    // Colors
    const COLOR_MAP = {
        [PATH]: '#6B6B6B',      // í†µë¡œ (ì§„í•œ íšŒìƒ‰)
        [WALL]: '#333333',      // ë²½/ì°¨ëŸ‰ (ì•„ì£¼ ì§„í•œ íšŒìƒ‰)
        [ENTRANCE]: '#10B981',  // ì‹œì‘ (ì—ë©”ë„ë“œ ê·¸ë¦°)
        [EMPTY_A]: '#F97316',   // ì£¼í™©
        [EMPTY_B]: '#3B82F6',   // íŒŒë‘
        [EMPTY_C]: '#EF4444',   // ë¹¨ê°•
        [EMPTY_D]: '#8B5CF6',   // ë³´ë¼ (New)
        [EMPTY_E]: '#059669',   // ì´ˆë¡ (New)
        [SCAN]: '#FDE047',      // ìŠ¤ìº” ì¤‘ (ë…¸ë‘)
        [SHORTEST_PATH]: '#34D399' // ìµœë‹¨ ê²½ë¡œ (ë°ì€ ì´ˆë¡)
    };
    
    // Car State
    let car = { x: 0, y: 0, pathIndex: 0, currentPath: null };
    let grid = [];
    let emptySpaces = []; // [{x, y, id, code}]

    // Simulation Control
    let isRunning = false;
    let scanInterval, moveInterval;

    // Canvas setup
    const canvas = document.getElementById(CANVAS_ID);
    const ctx = canvas.getContext('2d');
    const resultDisplay = document.getElementById(RESULT_DISPLAY_ID);
    const startButton = document.getElementById(START_BUTTON_ID);

    // Directions for BFS (Up, Down, Left, Right)
    const DIRS = [
        { dx: 0, dy: -1 }, 
        { dx: 0, dy: 1 }, 
        { dx: -1, dy: 0 }, 
        { dx: 1, dy: 0 }
    ];

    /**
     * íŠ¹ì • ì…€ ì½”ë“œê°€ ë¹ˆ ì£¼ì°¨ ê³µê°„ ì½”ë“œì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
     * @param {number} cellCode - ì…€ì˜ ì½”ë“œ
     * @returns {boolean} - ë¹ˆ ê³µê°„ ì—¬ë¶€
     */
    function isCellEmptySpace(cellCode) {
        return ALL_EMPTY_CODES.includes(cellCode);
    }
    
    /**
     * ì£¼ì°¨ì¥ ê·¸ë¦¬ë“œ êµ¬ì¡°ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
     */
    function setupInitialGrid() {
        // 25x15 ê·¸ë¦¬ë“œ ì´ˆê¸°í™” (ê¸°ì¡´ êµ¬ì¡° ìœ ì§€)
        grid = Array(ROWS).fill(0).map(() => Array(COLS).fill(PATH));

        // 1. ì™¸ê³½ ë²½ ë° ìƒë‹¨/í•˜ë‹¨ ì£¼ì°¨ ê³µê°„ ì„¤ì •
        for (let r = 0; r < ROWS; r++) {
            grid[r][0] = WALL;
            grid[r][COLS - 1] = WALL;
        }
        for (let c = 0; c < COLS; c++) {
            grid[0][c] = WALL;
            grid[ROWS - 1][c] = WALL;
        }

        // 2. ì£¼ì°¨ ë©´ (ë²½) ì„¤ì • - ê¸°ì¡´ ë²½ ì„¤ì • ë¡œì§ì€ ìœ ì§€
        // ì¤‘ì•™ ì„¹ì…˜ ì£¼ì°¨ ë©´
        for (let r = 3; r <= 11; r += 2) {
            for (let c = 1; c < COLS - 1; c++) {
                if (c % 2 !== 0) {
                    grid[r][c] = WALL; 
                    grid[r][c + 8] = WALL;
                    grid[r][c + 16] = WALL;
                }
            }
        }
        
        // ìµœì¢… í†µë¡œ ì •ë¦¬
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (grid[r][c] !== WALL) {
                    grid[r][c] = PATH;
                }
            }
        }
        
        // ì£¼ìš” ë²½ (ì°¨ëŸ‰) ë‹¤ì‹œ ì„¤ì •
        for (let c = 2; c < COLS - 2; c += 2) {
            grid[1][c] = WALL;
            grid[ROWS - 2][c] = WALL;
        }
        const verticalWalls = [3, 4, 5, 6, 8, 9, 10, 11]; 
        const parkingCols = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]; 

        verticalWalls.forEach(r => {
            parkingCols.forEach(c => {
                grid[r][c] = WALL;
            });
        });
        
        // --- ìˆ˜ì •ëœ ë¶€ë¶„: ì¤‘ì•™ ê°€ë¡œ í†µë¡œ(r=7)ë¥¼ í¬í•¨í•œ ì£¼ìš” í†µë¡œë¥¼ ëª…í™•íˆ PATHë¡œ ì„¤ì • ---
        for (let r = 2; r < ROWS - 2; r++) { // r goes from 2 to 12
             for (let c = 1; c < COLS - 1; c++) {
                 // ë“œë¼ì´ë¸Œ ì›¨ì´ (í†µë¡œ) - r=7 (ì¤‘ì•™ ê°€ë¡œ í†µë¡œ)ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì¶”ê°€í•˜ì—¬ ë²½ìœ¼ë¡œ ì„¤ì •ëœ ë¶€ë¶„ì„ ë®ì–´ì”ë‹ˆë‹¤.
                 if (r === 2 || r === 7 || r === 12 || c === 7 || c === 17) {
                     grid[r][c] = PATH;
                 }
             }
        }

        // ì¤‘ì•™ ê¸°ë‘¥ ë˜ëŠ” ë§‰íŒ êµ¬ì—­ (ì‹œê°ì  ë‹¤ì–‘ì„±)
        grid[5][10] = WALL;
        grid[6][10] = WALL;
        grid[6][11] = WALL;
        grid[8][14] = WALL;
        grid[8][15] = WALL;
        grid[10][4] = WALL;
        
    }

    /**
     * ë¬´ì‘ìœ„ë¡œ 3, 4, ë˜ëŠ” 5ê°œì˜ ë¹ˆ ì£¼ì°¨ ê³µê°„(A, B, C, ...)ì„ ì„¤ì •í•©ë‹ˆë‹¤.
     */
    function placeEmptySpaces() {
        emptySpaces = [];
        const possibleSpaces = [];

        // 1. ë¬´ì‘ìœ„ ë¹ˆ ê³µê°„ ìˆ˜ ê²°ì • (3, 4, 5 ì¤‘)
        const numSpaces = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
        const spaceIds = ['A', 'B', 'C', 'D', 'E'].slice(0, numSpaces);
        const spaceCodes = [EMPTY_A, EMPTY_B, EMPTY_C, EMPTY_D, EMPTY_E].slice(0, numSpaces);

        // ëª¨ë“  ì£¼ì°¨ ë©´ (WALL) ì¤‘ ë¹ˆ ê³µê°„ í›„ë³´ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        for (let r = 1; r < ROWS - 1; r++) {
            for (let c = 1; c < COLS - 1; c++) {
                if (grid[r][c] === WALL) {
                    // ë²½(ì°¨ëŸ‰) ì¤‘ í†µë¡œ(PATH)ì— ì¸ì ‘í•œ ê³³ë§Œ ì£¼ì°¨ ê³µê°„ìœ¼ë¡œ ê°„ì£¼
                    if (DIRS.some(dir => 
                        grid[r + dir.dy] && 
                        grid[r + dir.dy][c + dir.dx] === PATH
                    )) {
                        possibleSpaces.push({ x: c, y: r });
                    }
                }
            }
        }

        // 2. ë¬´ì‘ìœ„ë¡œ Nê°œ ì„ íƒ
        for (let i = 0; i < numSpaces; i++) {
            if (possibleSpaces.length === 0) break;
            
            const randomIndex = Math.floor(Math.random() * possibleSpaces.length);
            const { x, y } = possibleSpaces.splice(randomIndex, 1)[0];
            
            const id = spaceIds[i];
            const code = spaceCodes[i];

            grid[y][x] = code;
            emptySpaces.push({ x, y, id, code });
        }
    }

    /**
     * ì‹œì‘ ìœ„ì¹˜ë¥¼ ì„¤ì •í•˜ê³  ìë™ì°¨ ê°ì²´ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
     */
    function setupEntrance() {
        // ì…êµ¬ ìœ„ì¹˜ ì„¤ì • (ì˜ˆ: ì¢Œì¸¡ í•˜ë‹¨ í†µë¡œ)
        const entranceX = 1;
        const entranceY = ROWS - 2;
        grid[entranceY][entranceX] = ENTRANCE;
        car.x = entranceX;
        car.y = entranceY;
    }

    /**
     * ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ë“œë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function drawGrid() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cellType = grid[r][c];
                
                // ë°°ê²½ ì±„ìš°ê¸°
                ctx.fillStyle = COLOR_MAP[cellType] || COLOR_MAP[PATH];
                ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                // ì£¼ì°¨ êµ¬íšì„  ë° í†µë¡œì„  ê·¸ë¦¬ê¸° (ì‹œê°ì  êµ¬ë¶„)
                if (isCellEmptySpace(cellType)) {
                    // ë¹ˆ ì£¼ì°¨ ê³µê°„ í…Œë‘ë¦¬
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(c * TILE_SIZE + 1, r * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                }

                // ì£¼ì°¨ ë©´ì— ë ˆì´ë¸” í‘œì‹œ (A, B, C, D, E)
                if (isCellEmptySpace(cellType)) {
                    const space = emptySpaces.find(s => s.code === cellType);
                    if (space) {
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 16px Inter';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(space.id, c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2);
                    }
                }
            }
        }
    }

    /**
     * ìë™ì°¨ë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function drawCar() {
        // ìë™ì°¨ ëª¨ì–‘ (ì§ì‚¬ê°í˜•)
        ctx.fillStyle = '#000000'; // ìë™ì°¨ ìƒ‰ìƒ
        const carSize = TILE_SIZE * 0.7;
        const offset = (TILE_SIZE - carSize) / 2;
        ctx.fillRect(car.x * TILE_SIZE + offset, car.y * TILE_SIZE + offset, carSize, carSize);
        
        // í—¤ë“œë¼ì´íŠ¸ (ì•ìª½ ë°©í–¥ í‘œì‹œ)
        ctx.fillStyle = '#FFEB3B';
        const lightSize = carSize / 5;
        // í˜„ì¬ëŠ” pathIndexë¥¼ í†µí•´ ë°©í–¥ì„ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, ì¤‘ì•™ì— ê°„ë‹¨í•œ í‘œì‹œë§Œ
        ctx.fillRect(car.x * TILE_SIZE + TILE_SIZE / 2 - lightSize / 2, car.y * TILE_SIZE + offset, lightSize, lightSize);
    }
    
    /**
     * BFS ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰í•˜ì—¬ ìµœë‹¨ ê²½ë¡œì™€ ê±°ë¦¬ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
     * @param {number} startX - ì‹œì‘ X ì¢Œí‘œ
     * @param {number} startY - ì‹œì‘ Y ì¢Œí‘œ
     * @returns {{distance: number, path: Array<{x: number, y: number}>, targetId: string}} ìµœë‹¨ ê²½ë¡œ ì •ë³´
     */
    function runBFS(startX, startY) {
        // BFSë¥¼ ìœ„í•œ í, ê±°ë¦¬ ë§µ, ë¶€ëª¨ ë§µ ì´ˆê¸°í™”
        let queue = [{ x: startX, y: startY, dist: 0 }];
        let visited = Array(ROWS).fill(0).map(() => Array(COLS).fill(false));
        let distance = Array(ROWS).fill(0).map(() => Array(COLS).fill(Infinity));
        let parent = Array(ROWS).fill(0).map(() => Array(COLS).fill(null));

        visited[startY][startX] = true;
        distance[startY][startX] = 0;
        
        let shortestPathData = { distance: Infinity, path: [], targetId: '' };
        
        let pathFoundCount = 0;
        const pathsFound = []; // ë°œê²¬ëœ ë¹ˆ ê³µê°„ì˜ ê²½ë¡œ ì •ë³´ë¥¼ ì €ì¥

        const simulationSteps = []; // ìŠ¤ìº” ê³¼ì •ì„ ì‹œê°í™”í•˜ê¸° ìœ„í•œ ë‹¨ê³„ ì €ì¥

        // BFS ì‹¤í–‰
        while (queue.length > 0) {
            const current = queue.shift();
            const { x, y, dist } = current;

            // ì‹œê°í™” ë‹¨ê³„ ê¸°ë¡ (ê²½ë¡œë¥¼ ìŠ¤ìº” ì¤‘ì„ì„ í‘œì‹œ)
            if (grid[y][x] === PATH) {
                simulationSteps.push({ x, y, type: SCAN });
            }

            // ë¹ˆ ê³µê°„ ë°œê²¬!
            const isTarget = isCellEmptySpace(grid[y][x]);
            if (isTarget) {
                const targetSpace = emptySpaces.find(s => s.x === x && s.y === y);
                
                // ìµœë‹¨ ê²½ë¡œ ì¬êµ¬ì„±
                let path = [];
                let curr = { x, y };
                while(curr) {
                    path.unshift(curr);
                    curr = parent[curr.y][curr.x];
                }
                
                // ì‹œì‘ ë…¸ë“œ ì œê±° (ê²½ë¡œì—ëŠ” ë¹ˆ ê³µê°„ê¹Œì§€ë§Œ í¬í•¨)
                if (path.length > 0) path.shift(); 
                
                pathsFound.push({
                    distance: dist, 
                    path: path, 
                    targetId: targetSpace.id
                });
                
                pathFoundCount++;
                
                // ëª¨ë“  ë¹ˆ ê³µê°„ì„ ë°œê²¬í–ˆìœ¼ë©´ íƒìƒ‰ ì¢…ë£Œ
                if (pathFoundCount === emptySpaces.length) break; 
            }

            // 4ë°©í–¥ íƒìƒ‰
            for (const dir of DIRS) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;

                // ìœ íš¨ì„± ê²€ì‚¬ (ê²½ê³„, ë°©ë¬¸ ì—¬ë¶€, ë²½ì´ ì•„ë‹Œì§€)
                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && 
                    !visited[ny][nx] && grid[ny][nx] !== WALL) {
                    
                    // ì£¼ì°¨ ê³µê°„(A, B, C, D, E)ë„ íƒìƒ‰ ê°€ëŠ¥í•´ì•¼ í•¨ (ìµœì¢… ë„ì°©ì§€)
                    if (grid[ny][nx] === PATH || isCellEmptySpace(grid[ny][nx])) {
                        visited[ny][nx] = true;
                        distance[ny][nx] = dist + 1;
                        parent[ny][nx] = { x, y };
                        queue.push({ x: nx, y: ny, dist: dist + 1 });
                    }
                }
            }
        }

        // ë°œê²¬ëœ ê²½ë¡œ ì¤‘ ìµœë‹¨ ê²½ë¡œ ì„ íƒ
        if (pathsFound.length > 0) {
            shortestPathData = pathsFound.reduce((min, current) => 
                (current.distance < min.distance ? current : min), 
                pathsFound[0]
            );
        }
        
        // ì‹œê°í™” ë‹¨ê³„ë¥¼ ì €ì¥í•˜ì—¬ ë°˜í™˜
        return { shortestPathData, simulationSteps };
    }


    /**
     * ì‹œë®¬ë ˆì´ì…˜ì˜ ìŠ¤ìº” ë‹¨ê³„ë¥¼ ì‹œê°í™”í•©ë‹ˆë‹¤.
     * @param {Array} steps - ì‹œê°í™”í•  ë‹¨ê³„ ë°°ì—´
     */
    function startScanning(steps) {
        let stepIndex = 0;
        let tempGrid = JSON.parse(JSON.stringify(grid)); // ì›ë³¸ ê·¸ë¦¬ë“œ ë³µì‚¬
        
        clearInterval(scanInterval);
        
        const spaceNames = emptySpaces.map(s => s.id).join(', ');
        resultDisplay.innerHTML = `ğŸ” **ìŠ¤ìº” ì¤‘:** ë¹ˆ ì£¼ì°¨ ê³µê°„ ${spaceNames}ì„ íƒìƒ‰í•©ë‹ˆë‹¤...`;

        // ìŠ¤ìº” ê³¼ì • ì• ë‹ˆë©”ì´ì…˜
        scanInterval = setInterval(() => {
            if (stepIndex >= steps.length) {
                clearInterval(scanInterval);
                
                // --- ìˆ˜ì •ëœ ë¶€ë¶„: ìŠ¤ìº” ì™„ë£Œ í›„ ë¹ˆ ê³µê°„ ì´ ê°œìˆ˜ í‘œì‹œ ---
                const totalEmptySpaces = emptySpaces.length;
                resultDisplay.innerHTML = `âœ… **ìŠ¤ìº” ì™„ë£Œ!** ì´ <span class="text-blue-600 font-bold">${totalEmptySpaces}ê°œ</span>ì˜ ë¹ˆ ê³µê°„(${spaceNames})ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ìµœë‹¨ ê²½ë¡œë¡œ ì´ë™ì„ ì‹œì‘í•©ë‹ˆë‹¤.`;

                // 1.5ì´ˆ í›„ ì´ë™ ì‹œì‘ (ì‚¬ìš©ìì—ê²Œ ë©”ì‹œì§€ë¥¼ ë³´ì—¬ì¤„ ì‹œê°„)
                setTimeout(() => {
                    startMovement(shortestPath.path, shortestPath.targetId);
                }, 1500);
                // ---------------------------------------------------

                return;
            }

            const { x, y } = steps[stepIndex];
            
            // PATHì¸ ê²½ìš°ì—ë§Œ SCAN í‘œì‹œ (ë¹ˆ ê³µê°„ì€ ìƒ‰ìƒ ìœ ì§€)
            if (grid[y][x] === PATH) {
                tempGrid[y][x] = SCAN;
            }
            
            // í˜„ì¬ ìŠ¤ìº” ìƒí™©ì„ ê¸°ë°˜ìœ¼ë¡œ ì„ì‹œ ê·¸ë¦¬ë“œë¥¼ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
            drawTempGrid(tempGrid);
            drawCar();

            stepIndex++;
        }, 50); // ìŠ¤ìº” ì†ë„ ì¡°ì ˆ

        /**
         * ì„ì‹œ ê·¸ë¦¬ë“œë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
         */
        function drawTempGrid(currentGrid) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    let cellType = currentGrid[r][c];
                    
                    // ë¹ˆ ê³µê°„(A, B, C, D, E)ì€ ì›ë³¸ ìƒ‰ìƒì„ ìœ ì§€í•˜ë„ë¡ ë®ì–´ì”Œì›€
                    if (isCellEmptySpace(grid[r][c])) {
                        cellType = grid[r][c];
                    }
                    
                    ctx.fillStyle = COLOR_MAP[cellType] || COLOR_MAP[PATH];
                    ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    // ë ˆì´ë¸” ë° í…Œë‘ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    if (isCellEmptySpace(grid[r][c])) {
                        const space = emptySpaces.find(s => s.code === grid[r][c]);
                         ctx.strokeStyle = '#FFFFFF';
                         ctx.lineWidth = 2;
                         ctx.strokeRect(c * TILE_SIZE + 1, r * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                        if (space) {
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 16px Inter';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(space.id, c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2);
                        }
                    }
                }
            }
        }
    }
    
    /**
     * ìë™ì°¨ ì´ë™ì„ ì‹œì‘í•©ë‹ˆë‹¤.
     * @param {Array} path - ì´ë™í•  ê²½ë¡œ ë°°ì—´
     * @param {string} targetId - ìµœì¢… ëª©ì ì§€ ID
     */
    function startMovement(path, targetId) {
        if (path.length === 0) return;

        // ìµœë‹¨ ê²½ë¡œë¥¼ ê·¸ë¦¬ë“œì— í‘œì‹œ
        let finalGrid = JSON.parse(JSON.stringify(grid));
        path.forEach(p => {
            if (finalGrid[p.y][p.x] === PATH) {
                finalGrid[p.y][p.x] = SHORTEST_PATH;
            }
        });
        
        // ê²°ê³¼ í‘œì‹œ
        const distance = path.length;
        resultDisplay.innerHTML = `âœ… **ìµœë‹¨ ê±°ë¦¬ì˜ ì£¼ì°¨ ê³µê°„:** <span class="text-blue-600 font-bold">${targetId}</span> (ì´ ${distance} ë‹¨ê³„ ì´ë™)`;

        // ìë™ì°¨ ì´ë™ ì• ë‹ˆë©”ì´ì…˜
        car.currentPath = path;
        car.pathIndex = 0;
        
        // ì´ë™ ì‹œì‘ ì „ ìµœì¢… ê²½ë¡œ ì§€ë„ ê·¸ë¦¬ê¸°
        drawFinalMap(finalGrid);
        
        clearInterval(moveInterval);
        moveInterval = setInterval(() => {
            if (car.pathIndex >= car.currentPath.length) {
                clearInterval(moveInterval);
                resultDisplay.innerHTML = `ğŸ…¿ï¸ **ë„ì°© ì™„ë£Œ!** ì£¼ì°¨ ê³µê°„ ${targetId}ì— ì£¼ì°¨í–ˆìŠµë‹ˆë‹¤.`;
                return;
            }

            // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
            const nextPos = car.currentPath[car.pathIndex];
            car.x = nextPos.x;
            car.y = nextPos.y;
            car.pathIndex++;

            // ì§€ë„ì™€ ìë™ì°¨ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
            drawFinalMap(finalGrid);
            drawCar();

        }, 150); // ì´ë™ ì†ë„ ì¡°ì ˆ
        
        /**
         * ìµœì¢… ê²½ë¡œê°€ í‘œì‹œëœ ì§€ë„ë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
         */
        function drawFinalMap(currentGrid) {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cellType = currentGrid[r][c];
                    
                    // ë°°ê²½ ì±„ìš°ê¸°
                    ctx.fillStyle = COLOR_MAP[cellType] || COLOR_MAP[PATH];
                    ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    // ë ˆì´ë¸” ë° í…Œë‘ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    if (isCellEmptySpace(grid[r][c])) {
                        const space = emptySpaces.find(s => s.code === grid[r][c]);
                         ctx.strokeStyle = '#FFFFFF';
                         ctx.lineWidth = 2;
                         ctx.strokeRect(c * TILE_SIZE + 1, r * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                        if (space) {
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 16px Inter';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(space.id, c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2);
                        }
                    }
                }
            }
        }
    }


    // ì „ì—­ ë³€ìˆ˜ë¡œ BFS ê²°ê³¼ ì €ì¥
    let shortestPath = null;
    let simulationSteps = null;

    /**
     * ì‹œë®¬ë ˆì´ì…˜ì„ ì´ˆê¸°í™”í•˜ê³  ì‹œì‘í•©ë‹ˆë‹¤.
     */
    function initSimulation() {
        // ëª¨ë“  ì¸í„°ë²Œ ì •ë¦¬
        clearInterval(scanInterval);
        clearInterval(moveInterval);
        isRunning = false;
        
        // 1. ë§µ ì„¤ì • ë° ë¹ˆ ê³µê°„ ë°°ì¹˜
        setupInitialGrid();
        placeEmptySpaces(); // ì´ì œ 3, 4, 5ê°œ ì¤‘ ëœë¤ìœ¼ë¡œ ë°°ì¹˜ë¨
        setupEntrance();
        
        // 2. ì´ˆê¸° ë§µ ê·¸ë¦¬ê¸°
        drawGrid();
        drawCar();
        const spaceNames = emptySpaces.map(s => s.id).join(', ');
        resultDisplay.innerHTML = `ë¹ˆ ê³µê°„: ${spaceNames} (${emptySpaces.length}ê°œ). ì…êµ¬ì—ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.`;

        // 3. BFS ì‹¤í–‰ (ìŠ¤ìº” ì „ ê²½ë¡œ ê³„ì‚°)
        const bfsResult = runBFS(car.x, car.y);
        shortestPath = bfsResult.shortestPathData;
        simulationSteps = bfsResult.simulationSteps;
        
        if (shortestPath.path.length > 0) {
            startButton.textContent = "íƒìƒ‰ ì‹œì‘";
            startButton.onclick = startScanAndMove;
        } else {
             resultDisplay.innerHTML = `<span class="text-red-600">ì˜¤ë¥˜:</span> ë¹ˆ ê³µê°„ìœ¼ë¡œ ê°€ëŠ” ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.`;
             startButton.textContent = "ë‹¤ì‹œ ì´ˆê¸°í™”";
        }
    }
    
    /**
     * ìŠ¤ìº”ê³¼ ì´ë™ì„ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰í•˜ëŠ” í•¨ìˆ˜
     */
    function startScanAndMove() {
         if (isRunning) return;
         isRunning = true;
         startButton.textContent = "íƒìƒ‰ ì¤‘...";
         startButton.disabled = true; // ìŠ¤ìº” ì¤‘ ë²„íŠ¼ ë¹„í™œì„±í™”
         
         // ìŠ¤ìº” ì‹œì‘
         startScanning(simulationSteps);
         
         // ì´ë™ ì™„ë£Œ í›„ ë²„íŠ¼ ë‹¤ì‹œ í™œì„±í™” ë° ì´ˆê¸°í™” ê¸°ëŠ¥ ë³µêµ¬
         // ì´ ì‹œê°„ = (ìŠ¤ìº” ì‹œê°„) + (ê²°ê³¼ í‘œì‹œ ëŒ€ê¸° ì‹œê°„) + (ì´ë™ ì‹œê°„) + (ì—¬ìœ  ì‹œê°„)
         const totalTime = (simulationSteps.length * 50) + 1500 + (shortestPath.path.length * 150) + 500; 
         setTimeout(() => {
             startButton.textContent = "ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ / ì´ˆê¸°í™”";
             startButton.disabled = false;
             isRunning = false;
             startButton.onclick = initSimulation;
         }, totalTime);
    }
    
    // ì´ˆê¸° ë¡œë“œ ì‹œ ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •
    window.onload = () => {
        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;
        initSimulation();
    };
    
    // ë²„íŠ¼ ì´ˆê¸° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
    startButton.onclick = initSimulation;

</script>
</body>
</html>
